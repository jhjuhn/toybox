<!DOCTYPE HTML>
<html>
<head>
<link href = 'https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel = 'stylesheet' type = 'text/css'>
<style>
html, body {
	margin: 0; padding: 0;
	background-color: #fff;
	color: #999;

	font-family: 'open sans', sans-serif;
	font-size: 14px;
}
h2 { font-size: 18px; }

/*UI*/

#container {
	width: 720px;
	margin: 4px auto;
}
#credits{
	margin-top: 16px;
	font-size: 12px;
}

#pool {
	width: 720px;
	height: 720px;
}

</style>

</head>
<body>

<div id = "container">
	<h2>LIPID</h2>

	<canvas id = "pool"></canvas>
<script>
// SIMPLE 2-VECTOR LIBRARY
var Vector2 = function(x, y){ this.x = x; this.y = y; }
Vector2.prototype = {
	x: 0, y: 0,
	set: function(x, y) { this.x = x, this.y = y; },
	add: function(v, w) {
		if (v.x !== undefined) { this.x += v.x; this.y += v.y; }
		else { this.x += v, this.y += w; }
		return this;
	},
	sub: function(v, w) {
		if (v.x !== undefined) { this.x -= v.x; this.y -= v.y; }
		else { this.x -= v, this.y -= w; }
		return this;
	},
	mul: function(a) { this.x *= a; this.y *= a; return this; },
	div: function(a) { this.x /= a; this.y /= a; return this; },
	mag: function() { return Math.sqrt(this.x*this.x+this.y*this.y); },
	unit: function() {
		return this.mag()<V2.epsilon?
		this.set(0, 0):
		this.div(this.mag());
	},
	clone: function() { return new Vector2(this.x, this.y); },

	clip: function(m) {
		if (this.mag() < m) { return this; }
		return this.unit().mul(m);
	}
};
var V2 = {
	epsilon: 1e-10,

	add: function(u, v) { return new Vector2(u.x+v.x, u.y+v.y); },
	sub: function(u, v) { return new Vector2(u.x-v.x, u.y-v.y); },
	mul: function(a, u) { return new Vector2(a*u.x, a*u.y); },
	div: function(a, u) { return new Vector2(u.x/a, u.y/a); },
	unit: function(u) { return u.clone().unit(); }
};
</script>

<script>
var Particle = function(x, y, m){
	this.m = 1;
	this.q = new Vector2(x, y);
	this.prev_q = new Vector2(x, y);

	this.f = new Vector2(0, 0);
}
Particle.prototype = {

	integrate: function(dt, damping){

		var new_q = this.q.clone().mul(2).sub(this.prev_q).add(
			V2.mul(this.m*dt*dt, this.f));
		this.prev_q = this.q;

		this.q = new_q;
		this.q.sub(V2.sub(this.q, this.prev_q).mul(damping));
		
		this.f.set(0, 0);
	}
};



var Lipid = function(x, y, thet){
	this.head = new Particle(x, y, 1);
	this.tail = new Particle(
		this.head.q.x+this.l*Math.cos(thet),
		this.head.q.y+this.l*Math.sin(thet),
		1);
}
Lipid.prototype = {
	l: 8,
	r: 2,

	integrate: function(dt, L, damping){
		// move individual ends
		this.head.integrate(dt, damping);
		this.tail.integrate(dt, damping);

		// solve length constraint
		
		var d = V2.sub(this.head.q, this.tail.q);
		var p = (d.mag()-this.l)/2;
		d.unit();

		
		this.head.q.sub(V2.mul(p, d));
		this.tail.q.add(V2.mul(p, d));

	},
	draw: function(ctx){
		ctx.beginPath();
		ctx.arc(this.head.q.x, this.head.q.y,
		this.r, 0, 2*Math.PI);
		ctx.fill();

		ctx.beginPath();
		ctx.moveTo(this.head.q.x, this.head.q.y);
		ctx.lineTo(this.tail.q.x, this.tail.q.y);
		ctx.stroke();

	}
};



// a sigmoid function that takes goes from 0 to 1
function sgm(x){ return 0.5+2*x/Math.sqrt(1+16*x*x); }

function ramp(near, far, threshold, width){
	// interpolates between near and far values, making
	// jump at threshold with width being the distance
	// from threshold required to nearly reach target value.
	// beyond range, force is taken to be zero.
	return function(r){
		return near+sgm((r-threshold)/width)*(far-near);
	};
}

function force_hh(r){
	return (ramp(-6, 0, 30, 10)(r) +
		ramp(20, 0, 15, 5)(r) +
		ramp(80, 0, 10, 3)(r));
}
function force_tt(r){
	return 0;
	return (ramp(-6, 0, 30, 10)(r) +
		ramp(80, 0, 10, 3)(r));
}
function force_ht(r){
	return (ramp(3, 0, 30, 10)(r) +
		ramp(80, 0, 10, 3)(r));
}
function force(a, b, forcefunc){
	var r = V2.sub(b.q, a.q);
	var m = forcefunc(r.mag());
	r.unit().mul(m);

	a.f.sub(r); b.f.add(r);
}



var Pool = function(L, dt, damping){
	this.lipids = [];

	this.L = L;
	this.dt = dt;

	this.damping = damping;

	this.canv = document.getElementById('pool');
	this.canv.width = this.canv.height = this.L;
	this.ctx = this.canv.getContext('2d');
}
Pool.prototype = {
	addLipid: function(x, y, thet){
		this.lipids.push(new Lipid(x, y, thet));
	},
	addRandomLipids: function(n) {
		for (var i = 0; i < n; ++i) {
			this.addLipid(
			Math.random()*this.L,
			Math.random()*this.L,
			Math.random()*2*Math.PI
			);
		}
	},
	integrate: function(){
		for (var i = 0; i < this.lipids.length; ++i) {
			this.lipids[i].integrate(
			this.dt, this.L, this.damping);
		}
	},
	forces: function(){
	
		// brownian
		var b_mag = 10;
		for (var i = 0; i < this.lipids.length; ++i) {
			this.lipids[i].head.f.set(
				b_mag*2*Math.random()-b_mag,
				b_mag*2*Math.random()-b_mag);
			this.lipids[i].tail.f.set(
				b_mag*2*Math.random()-b_mag,
				b_mag*2*Math.random()-b_mag);
		}

		// crummy N^2 thingy. TODO: spatial hash maybe
		for (var i = 0; i < this.lipids.length; ++i) {
		for (var j = i+1; j < this.lipids.length; ++j) {
			force(this.lipids[i].head, this.lipids[j].head, force_hh);
			force(this.lipids[i].tail, this.lipids[j].tail, force_tt);

			force(this.lipids[i].head, this.lipids[j].tail, force_ht);
			force(this.lipids[j].head, this.lipids[i].tail, force_ht);
		}}


	},
	render: function(){
		this.ctx.clearRect(0, 0, this.canv.width, this.canv.height);
		for (var i = 0; i < this.lipids.length; ++i) {
			this.lipids[i].draw(this.ctx);
		}
	},
	timestep: function(){
		this.forces();
		this.integrate();
		this.render();
	},
	run: function(){
		this.timestep();
		window.requestAnimationFrame(this.run.bind(this));
	}
}

var pool = new Pool(720, 0.05, 0.04);
//pool.addRandomLipids(400);

for (var i = 0; i < 10; ++i) {
for (var j = 0; j < 10; ++j) {
	pool.addLipid(20+i*50, 20+j*10, Math.random()*2*Math.PI);
	pool.addLipid(32+i*50, 20+j*10, Math.random()*2*Math.PI);
}}
pool.run();


</script>

	<div><p>description.</p></div>

	<div id = "credits">
	J. Lok, [M] [yyyy].
	</div>

</div>


</body>

</html>
