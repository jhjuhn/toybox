<!DOCTYPE HTML>
<html>
<head>
<link href = 'https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel = 'stylesheet' type = 'text/css'>
<style>
html, body {
	margin: 0; padding: 0;
	background-color: #fff;
	color: #999;

	font-family: 'open sans', sans-serif;
	font-size: 14px;
}
h2 { font-size: 18px; }

/*UI*/

#container {
	width: 720px;
	margin: 4px auto;
}
#credits{
	margin-top: 16px;
	font-size: 12px;
}

/* WORLD*/

#canv {
	border: 1px #ccc dashed;

	margin: 4px auto;

	position: relative;

	width: 720px;
	height: 720px;

	/*overflow: hidden;*/
}

</style>
<script>


</script>

</head>
<body>

<div id = "container">
	<h2>TITLE</h2>

	<canvas id = "canv" width = "720" height = "720"></canvas>
	<script>

var Schroedinger = function(){
	this.x_max = 6;	// integration range -x_max to x_max
	this.dx = 0.05;	// space discretisation
	this.N = 2*this.x_max/this.dx;

	// potential function
	this.V = function(x) {
		//return 0;
		//return Math.abs(x) > 0.7?6000:0;
		return x*x;
	};

	this.E_n = [];	// list of energy eigenvalues
	this.phi_n = [];	// list of eigenstates


};
Schroedinger.prototype = {
f: function(E, x) {
	return 2*(this.V(x)-E);
},

shoot: function(E){ // returns phi at the other end of the range

	var x = -this.x_max;

	var phi = 0;
	var phi_prev = -1;
	var phi_next;

	var f = this.f(E, x);
	var f_prev = this.f(E, x-this.dx);
	var f_next;

	var b = this.dx*this.dx/12;

	var intg = 0;	// normalisation not needed, this
			// function used to determine sign
			// only.

	for (var i = 0; i < this.N; ++i) {

		f_next = this.f(E, x+this.dx);

		//phi_next = 2*phi - phi_prev + this.dx*this.dx*f*phi; // verlet
		phi_next = (2*phi*(1+5*b*f) - phi_prev*(1-b*f_prev))/(1-b*f_next);

		phi_prev = phi;
		phi = phi_next;

		f_prev = f;
		f = f_next;

		x += this.dx;

		intg += 0.5*this.dx*(phi*phi + phi_prev*phi_prev);
	}
	phi /= Math.sqrt(intg);

	return phi;
},

integrate: function(E){ // returns an array

	var phi = [];
	phi[-1] = -1;
	phi[0] = 0;

	var x = -this.x_max;

	var f = this.f(E, x);
	var f_prev = this.f(E, x-this.dx);
	var f_next;

	var intg = 0;

	var b = this.dx*this.dx/12;

	for (var i = 0; i < this.N; ++i) {

		f_next = this.f(E, x+this.dx);

		//phi[i+1] = 2*phi[i] - phi[i-1] + this.dx*this.dx*f*phi[i];
		phi[i+1] = (2*phi[i]*(1+5*b*f) - phi[i-1]*(1-b*f_prev))/(1-b*f_next);

		f_prev = f;
		f = f_next;

		x += this.dx;
		intg += 0.5*this.dx*(phi[i+1]*phi[i+1]+phi[i]*phi[i]);
	}
	delete phi[-1];

	intg = Math.sqrt(intg);
	for (var i = 0; i < this.N+1; ++i) { phi[i] /= intg; }

	return phi;
},

eigensolve: function(N){

	// returns [ E1, E2 ] bracketing energies
	var eigenbracket = function(E_min, E_max, dE){
		
		var E1 = E_min;
		var E2;
	
		var phi1 = this.shoot(E1);
		var phi2;

		var res = undefined;
	
		// first find bracketing energies
		while ((E2 = E1 + dE) <= E_max) {
	
			var phi2 = this.shoot(E2);
			if (phi1*phi2 < 0) {
				//console.log('bracketing energies: ' +
				//E1 + ', ' + E2);

				res = [ E1, E2 ];
				break;
			}
	
			phi1 = phi2;
			E1 = E2;
		}

		return res;
	}.bind(this);
	
	// returns eigenstate energy s.t. boundary condition is
	// satisfied to within epsilon
	var eigenbisect = function(E_min, E_max, phi_target, epsilon){
		var E_mid = (E_min + E_max)/2;
		var phi_min = this.shoot(E_min);
		var phi_mid = this.shoot(E_mid);
		var phi_max = this.shoot(E_max);

		var iter = 0;
		var max_iter = 10000;

		while (Math.abs(phi_mid - phi_target) > epsilon &&
		iter < max_iter) {

			if (phi_mid*phi_max < 0) {
				E_min = E_mid;
				phi_min = phi_mid;
			} else {
				E_max = E_mid;
				phi_max = phi_mid;
			}

			E_mid = (E_min + E_max)/2;
			phi_mid = this.shoot(E_mid);

			++iter;
		}
		if (Math.abs(phi_mid - phi_target) > epsilon) {
			console.log('! bisection failed to converge (' +
			phi_mid + ' left)');
		}

		return E_mid;
	}.bind(this);


	this.E_n = [];
	var E_start = 0;
	var E_end = Infinity; // loop runs indefinitteelllyyy

	for (var i = 0; i < N; ++i) {
		var bracket = eigenbracket(E_start, E_end, 0.01);
		if (!bracket) {
			console.log('failed');
			return false;
		}

		var Ei = eigenbisect(bracket[0], bracket[1], 0, 1e-6);
		//console.log('E_' + i + ' = ' + Ei);

		// add the found eigenfunction & energy to list
		this.E_n[i] = Ei;
		this.phi_n[i] = this.integrate(Ei);


		E_start = bracket[1];
	}
	
}

};

// draws f, an array of values, on ctx
function graph(ctx, f, yscale){
	var n = f.length-1;

	var w = ctx.canvas.width;
	var h = ctx.canvas.height;

	var wprop = 1.0;
	var hprop = 1.0;

	var dx = w*wprop/n;
	var dy = h*hprop/2/yscale;

	ctx.beginPath();
	ctx.moveTo(0, h/2);
	for (var i = 0; i < f.length; ++i) {
		ctx.lineTo(dx*i, -f[i]*dy+h/2);
	}
	ctx.stroke();

}



var canv = document.getElementById('canv');
var ctx = canv.getContext('2d');

var sch = new Schroedinger();
sch.eigensolve(4);
graph(ctx, sch.phi_n[0], 2);
graph(ctx, sch.phi_n[1], 2);
graph(ctx, sch.phi_n[2], 2);
graph(ctx, sch.phi_n[3], 2);

	</script>

	<div><p>description.</p></div>

	<div id = "credits">
	J. Lok, [M] [yyyy].
	</div>

</div>


</body>

</html>
