<!DOCTYPE HTML>
<html>
<head>
<link href = 'https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel = 'stylesheet' type = 'text/css'>
<style>
html, body {
	margin: 0; padding: 0;
	background-color: #fcfcfc;
	color: #f8f;
	text-shadow: 2px 0 #7ff;

	font-family: 'open sans', sans-serif;
	font-size: 14px;
}
h2 {
	font-size: 18px;
	color: #f8f;
	text-shadow: 4px 0 #7ff;
}

/*UI*/

#container {
	width: 720px;
	margin: 4px auto;
}
#credits{
	margin-top: 16px;
	font-size: 12px;
}

/* WORLD*/

#canv {
	border: none; /*1px #ccc dashed;*/

	margin: 4px auto;

	position: relative;

	width: 720px;
	height: 720px;

	/*overflow: hidden;*/
}

</style>
<script>


</script>

</head>
<body>

<div id = "container">
	<h2>QUANTUM HARMONIC OSCILLATOR</h2>

	<canvas id = "canv" width = "720" height = "720"></canvas>
	<script>

var Schroedinger = function(){
	this.x_max = 4;	// integration range -x_max to x_max
	this.dx = 0.01;// space discretisation
	this.N = 2*this.x_max/this.dx;

	// potential function
	this.V = function(x) {
		//return 0;
		return 2.1*x*x;
	};

	this.E_n = [];	// list of energy eigenvalues
	this.phi_n = [];	// list of eigenstates


};
Schroedinger.prototype = {
f: function(E, x) {
	return 2*(this.V(x)-E);
},

shoot: function(E){ // returns phi at the other end of the range

	var x = -this.x_max;

	var f = this.f(E, x);
	var f_prev = this.f(E, x-this.dx);
	var f_next;

	var phi = Math.exp(Math.sqrt(f)*x);
	var phi_prev = -0.1;
	var phi_next;

	var b = this.dx*this.dx/12;

	//var intg = 0;	// normalisation not needed, this
			// function used to determine sign
			// only.

	for (var i = 0; i < this.N; ++i) {

		f_next = this.f(E, x+this.dx);

		//phi_next = 2*phi - phi_prev + this.dx*this.dx*f*phi; // verlet
		phi_next = (2*phi*(1+5*b*f) - phi_prev*(1-b*f_prev))/(1-b*f_next);

		phi_prev = phi;
		phi = phi_next;

		f_prev = f;
		f = f_next;

		x += this.dx;

		//intg += 0.5*this.dx*(phi*phi + phi_prev*phi_prev);
	}
	//phi /= Math.sqrt(intg);

	return phi;
},

integrate: function(E){ // returns an array


	var x = -this.x_max;

	var f = this.f(E, x);
	var f_prev = this.f(E, x-this.dx);
	var f_next;

	var phi = [];
	phi[-1] = -0.1;
	phi[0] = Math.exp(-Math.sqrt(f)*x);

	var intg = 0;

	var b = this.dx*this.dx/12;

	for (var i = 0; i < this.N; ++i) {

		f_next = this.f(E, x+this.dx);

		//phi[i+1] = 2*phi[i] - phi[i-1] + this.dx*this.dx*f*phi[i];
		phi[i+1] = (2*phi[i]*(1+5*b*f) - phi[i-1]*(1-b*f_prev))/(1-b*f_next);

		f_prev = f;
		f = f_next;

		x += this.dx;
		intg += 0.5*this.dx*(phi[i+1]*phi[i+1]+phi[i]*phi[i]);
	}
	delete phi[-1];

	intg = Math.sqrt(intg);
	for (var i = 0; i < this.N+1; ++i) { phi[i] /= intg; }

	return phi;
},

eigensolve: function(N){

	// returns [ E1, E2 ] bracketing energies
	var eigenbracket = function(E_min, E_max, dE){
		
		var E1 = E_min;
		var E2;
	
		var phi1 = this.shoot(E1);
		var phi2;

		var res = undefined;
	
		// first find bracketing energies
		while ((E2 = E1 + dE) <= E_max) {
	
			var phi2 = this.shoot(E2);
			if (phi1*phi2 < 0) {
				res = [ E1, E2 ];
				break;
			}
	
			phi1 = phi2;
			E1 = E2;
		}

		return res;
	}.bind(this);
	
	// returns eigenstate energy s.t. boundary condition is
	// satisfied to within epsilon
	var eigenbisect = function(E_min, E_max, phi_target, epsilon){
		var E_mid = (E_min + E_max)/2;
		var phi_min = this.shoot(E_min);
		var phi_mid = this.shoot(E_mid);
		var phi_max = this.shoot(E_max);

		var iter = 0;
		var max_iter = 60;

		while (Math.abs(phi_mid - phi_target) > epsilon &&
		iter < max_iter) {
			if (phi_mid*phi_max < 0) {
				E_min = E_mid;
				phi_min = phi_mid;
			} else {
				E_max = E_mid;
				phi_max = phi_mid;
			}

			E_mid = (E_min + E_max)/2;
			phi_mid = this.shoot(E_mid);

			++iter;
		}
		if (Math.abs(phi_mid - phi_target) > epsilon) {
			console.log('! bisection failed to converge (' +
			phi_mid + ')');
		}

		return E_mid;
	}.bind(this);


	this.E_n = [];
	var E_start = 0;
	var E_end = Infinity; // loop runs indefinitteelllyyy

	for (var i = 0; i < N; ++i) {
		var bracket = eigenbracket(E_start, E_end, 0.01);
		if (!bracket) {
			console.log('failed');
			return false;
		}

		var Ei = eigenbisect(bracket[0], bracket[1], 0, 1e-6);
		console.log('E_' + i + ' = ' + Ei);

		// add the found eigenfunction & energy to list
		this.E_n[i] = Ei;
		this.phi_n[i] = this.integrate(Ei);


		E_start = bracket[1];
	}
	
}

};

// draws f, an array of values, on ctx
function graph(ctx, f, yscale, clear, style){
	if (clear) {
		ctx.clearRect(0, 0,
		ctx.canvas.width, ctx.canvas.height);
	}
	if (style) {
		ctx.strokeStyle = style;
	}

	var n = f.length-1;

	var w = ctx.canvas.width;
	var h = ctx.canvas.height;

	var wprop = 1.0;
	var hprop = 1.0;

	var dx = w*wprop/n;
	var dy = h*hprop/2/yscale;

	ctx.beginPath();
	ctx.moveTo(0, h/2);
	for (var i = 0; i < f.length; ++i) {
		ctx.lineTo(dx*i, -f[i]*dy+h/2);
	}
	ctx.stroke();

}

// dot product for orthonormality checks.
function dot(f1, f2, dx){
	var intg = 0;
	var L = Math.max(f1.length, f2.length);
	for (var i = 0; i < f1.length-1; ++i) {
		intg += 0.5*dx*(f1[i]*f2[i]+f1[i+1]*f2[i+1])
	}
	return intg;
}

var Wave = function(sch, psi){
	this.sch = sch;

	// real & imaginary parts of function
	this.Re = [];
	this.Im = [];

	this.components = []; // this.sch.E_n.length;

	this.from(psi);
};
Wave.prototype = {
	from: function(f){
		this.components = this.decompose(this.generate(f));
		this.evolve(0);
	},
	generate: function(f){
		// returns an array representing a normalised
		// wave function

		var psi = []; var intg = 0;
		var x = -this.sch.x_max;

		psi[0] = f(x);
		for (var i = 0; i < this.sch.N; ++i) {
			x += this.sch.dx;

			psi[i+1] = f(x);

			intg += 0.5*this.sch.dx*
				(psi[i]*psi[i]+	psi[i+1]*psi[i+1]);
		}

		// normalise
		intg = Math.sqrt(intg);
		for (var i = 0; i < this.sch.N+1; ++i) {
			psi[i] /= intg;
		}
		return psi;
	},
	decompose: function(val){
		// returns a decomposition of f as
		// eigenvalues of associated schroedinger eq.

		var components = [];
		for (var i = 0; i < this.sch.phi_n.length; ++i) {
			components[i] = dot(val,
			this.sch.phi_n[i], this.sch.dx);
		}
		return components;
	},
	evolve: function(t){

		for (var j = 0; j < this.sch.N+1; ++j) {
		this.Re[j] = this.Im[j] =  0;

		for (var i = 0; i < this.sch.phi_n.length; ++i) {
			this.Re[j] += 
			Math.cos(this.sch.E_n[i]*t)*
			this.sch.phi_n[i][j]*this.components[i];

			this.Im[j] += 
			Math.sin(this.sch.E_n[i]*t)*
			this.sch.phi_n[i][j]*this.components[i];
		}}
	}
};


/* initialise graphics */
var canv = document.getElementById('canv');
var ctx = canv.getContext('2d');
ctx.lineWidth = 8;

/* solve eigenvalue problem */
var sch = new Schroedinger();

var N = 14; 
sch.eigensolve(N);

/* check for orthogonality */
/*
for (var i = 0; i < sch.phi_n.length; ++i) {
for (var j = i; j < sch.phi_n.length; ++j) {
console.log('phi_' + i + '*phi_' + j + ': ' + 
dot(sch.phi_n[i], sch.phi_n[j], sch.dx).toFixed(8));
}}
*/

/* express initial conditions */
var wave = new Wave(sch, function(x){
	x = 1.8*(x-1);
	return 3*Math.exp(-x*x);
});

/* graph eigenvalues */
//for (var i = 0; i < N; ++i) { graph(ctx, sch.phi_n[i], 1.5); }


var t = 0; var dt = 0.01;
window.setInterval(function(){
wave.evolve(t); t += dt;
graph(ctx, wave.Re, 1.5, 1, 'rgba(0, 255, 255, 0.5)');
graph(ctx, wave.Im, 1.5, 0, 'rgba(255, 130, 255, 0.5)');

}, 20);




	</script>

	<div><p>The real (cyan) and imaginary (magenta) parts of the wave function of a quantum harmonic oscillator. The time-independent Schr√∂dinger equation is solved with a shooting method to obtain the first 14 eigenvalues, by which an initial wave function is approximated, and time evolution is applied.</p></div>

	<div id = "credits">
	J. Lok, August 2017.
	</div>

</div>


</body>

</html>
