<!DOCTYPE HTML>
<html>
<head>
<link href = 'https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel = 'stylesheet' type = 'text/css'>
<style>
html, body {
	margin: 0; padding: 0;
	background-color: #fff;
	color: #999;

	font-family: 'open sans', sans-serif;
	font-size: 14px;
}
h2 { font-size: 18px; }

/*UI*/

#container {
	width: 720px;
	margin: 4px auto;
}
#credits{
	margin-top: 16px;
	font-size: 12px;
}

/* WORLD*/

#world {
	border: 1px #ccc none;/*dashed;*/

	margin: 4px auto;

	position: relative;

	width: 720px;
	height: 720px;

	overflow: hidden;
}

.particle {
	position: absolute;
	border-radius: 100%;
}
.p-magnetic {
	background-color: #f66;
}

</style>

</head>
<body>

<div id = "container">
	<h2>TITLE</h2>

	<div id = "world" width = "720" height = "720"></div>
	<script src = "../shared/v4.js"></script>
	<script src = "../shared/spash.js"></script>
	<script src = "../shared/hsv2hex.js"></script>
	<script>
const Particle = function (params) {
	this.q = [ params.x, params.y, 0, 1 ];
	this.q_prev = this.q.v4clone();
	this.a = [ 0, 0, 0, 1 ];

	this.neighbours = [];
	this.order = 0;

	this.m = params.m;
}
Particle.prototype.diameter = 17;
Particle.prototype.margin = 2;
Particle.prototype.integrate = function (dt) {
	let old_q = this.q.v4clone();
	this.q.v4mul(2).v4sub(this.q_prev)
		.v4add(this.a.v4mul(dt*dt/2));
	
	/* damp */
	const damping = 0.01;
	this.q.v4mul(1-damping).v4add(v4mul(damping, old_q));
	this.q_prev = old_q;

	/* ad-hoc clamp */
	this.q[0] = Math.max(0, Math.min(this.q[0], 720));
	this.q[1] = Math.max(0, Math.min(this.q[1], 720));
}
Particle.prototype.initVisual = function (ref) {
	const div = document.createElement("div");
	div.classList.add("particle");
	div.style.width = (this.diameter - this.margin) + 'px';
	div.style.height = (this.diameter - this.margin) + 'px';
	//div.style.border = this.margin + 'px solid #fff';
		
	ref.appendChild(div);

	this.visual = div;
}
Particle.prototype.syncVisual = function () {
	const div = this.visual;
	if (!div) { return; }

	const c = 1;//Math.cos(this.theta);
	const s = 0;//Math.sin(this.theta);
	const w = this.diameter/2;

	div.style.transform = "matrix(" +
	c + "," + (-s) + "," +
	s + "," +   c  + "," +
	(this.q[0]-w) + "," + (this.q[1]-w) + ")";

	div.style.backgroundColor = HSVtoHex(
		0.6,
		//(0.6+0.4*this.q[0]/720+1)%1,
		0.8,
		Math.min(Math.max(0, 0.8+0.15*this.m), 1));
}

const Lab = function (params) {
	this.phi = params.phi;
	this.H = [ 0,
		Math.sin(this.phi),
		Math.cos(this.phi),
		1].v4mul(4.5);
	this.T = params.T;
	this.particles = [];
	this.ref = params.ref;
	this.dt = 0.2;

	this.sh = new Spash(720, 32);
}
Lab.prototype.updateHash = function () {
	this.sh.empty();
	for (let i = 0; i < this.particles.length; ++i) {
		this.sh.insert(
			this.particles[i].q[0],
			this.particles[i].q[1],
			i);
	}

	for (let i = 0; i < this.particles.length; ++i) {
		this.particles[i].order = 0;
	}
	const thres = 1.5;
	for (let i = 0; i < this.particles.length; ++i) {
		const p = this.particles[i];
		p.neighbours = this.sh.lookup(p.q[0], p.q[1]);

		for (let j in p.neighbours) {
			if (i < j) {
				const d = v4sub(
					p.q,
					this.particles[j].q).v4mag()/
					p.diameter;

				if (d < thres) {
					const inc = thres-d;
					p.order += inc;
					this.particles[j].order += inc;
				}
				/* calculate order diameter, to do */
				//p.order += 1;
				//this.particles[j].order += 1;
			}
		}
	}

	/* debug */
	minord = 100;
	maxord = 0;
	for (let i = 0; i < this.particles.length; ++i) {
		maxord = Math.max(maxord, this.particles[i].order);
		minord = Math.min(minord, this.particles[i].order);
	}
	console.log(maxord, minord);
}
Lab.prototype.addParticle = function (params) {
	const p = new Particle(params);
	p.initVisual(this.ref);

	this.particles.push(p);
}
Lab.prototype.forces = function () {
	for (let i = 0; i < this.particles.length; ++i) {
		this.particles[i].a.v4set(0, 0, 0);
	}
	/* brownian */
	for (let i = 0; i < this.particles.length; ++i) {
		const th = Math.random()*Math.PI*2;
		this.particles[i].a =
			[ this.T*Math.cos(th), this.T*Math.sin(th), 0, 1];
	}
	/* dipole-dipole */
	function dforces (H, pa, pb) {
		const ma = v4mul(pa.m, H);
		const mb = v4mul(pb.m, H);
		const r = v4sub(pb.q, pa.q);
		const d = v4mag(r);
		if (d > 32) { return; }

		const c = 1e4;
		
		const F = v4mul(c/Math.pow(d, 5),
		v4mul(v4dot(ma, r), mb).v4add(
		v4mul(v4dot(mb, r), ma)).v4add(
		v4mul(v4dot(ma, mb), r)).v4sub(
		v4mul(
			5*v4dot(ma, r)*v4dot(mb, r)/d/d,
			r)));

		F[2] = 0;
		pa.a.v4sub(F);
		pb.a.v4add(F);

	}

	for (let i = 0; i < this.particles.length; ++i) {
		for (let j in this.particles[i].neighbours) {
			if (i < j) {
				dforces(
				this.H,
				this.particles[i],
				this.particles[j]);
			}
		}
	}

	/*
	for (let i = 0; i < this.particles.length; ++i) {
	for (let j = i+1; j < this.particles.length; ++j) {
		dforces(
			this.H,
			this.particles[i],
			this.particles[j]);
	}}
	*/
}
Lab.prototype.constraints = function () {
	function constrain (pa, pb) {
		const u = v4sub(pb.q, pa.q);
		const d = u.v4mag();
		const offset = (pa.diameter-d)/2;
		if (offset <= 0) { return; }

		pa.q.v4sub(v4mul(offset/d, u));
		pb.q.v4add(v4mul(offset/d, u));

	}

	for (let i = 0; i < this.particles.length; ++i) {
		for (let j in this.particles[i].neighbours) {
			if (i < j) {
				constrain(
				this.particles[i],
				this.particles[j]);
			}
		}
	}

	/*
	for (let i = 0; i < this.particles.length; ++i) {
	for (let j = i+1; j < this.particles.length; ++j) {
		constrain(
			this.particles[i],
			this.particles[j]);
	}}
	*/
}

Lab.prototype.integrate = function () {
	for (let i = 0; i < this.particles.length; ++i) {
		this.particles[i].integrate(this.dt);
	}
}
Lab.prototype.render = function () {
	for (let i = 0; i < this.particles.length; ++i) {
		this.particles[i].syncVisual();
	}
}
Lab.prototype.timestep = function () {
	window.requestAnimationFrame(this.timestep.bind(this));

	this.updateHash();
	this.forces();
	this.integrate();	
	this.constraints();
	this.constraints();
	this.render();
}



const l = new Lab({
	ref: document.getElementById("world"),
	phi: 0,
	T: 2
});

window.addEventListener('keydown', function (e) {
	/* control temperature */
	if (e.key === "ArrowUp") {
		l.T = l.T ? Math.min(32, l.T *= 2) : 1;
	}
	if (e.key === "ArrowDown") {
		l.T = Math.floor(l.T/2);
	}

	/* control magnetic field direction */
	const phi_inc = Math.PI/12;
	if (e.key === "ArrowLeft") {
		l.phi = Math.min(Math.PI/2, l.phi + phi_inc);
		l.H = [ 0, Math.sin(l.phi),	Math.cos(l.phi), 1].v4mul(4.5);
	}
	if (e.key === "ArrowRight") {
		l.phi = Math.max(0, l.phi - phi_inc);
		l.H = [ 0, Math.sin(l.phi),	Math.cos(l.phi), 1].v4mul(4.5);
	}
	console.log("T = " + l.T + "; H = " + l.H);
});

/* initial array of particles */
const w = 22;
for (let i = 0; i < 720/w; ++i) {
for (let j = 0; j < 720/w; ++j) {
	l.addParticle({
		x: w*i,
		y: w*j,
		theta: 3.14*Math.random(),
		m: Math.random() > 0.5 ? 1 : -1
	});
}}
l.timestep();

	</script>	
	<div><p>description.</p></div>

	<div id = "credits">
	J. Lo, [M] [yyyy].
	</div>

</div>

</body>
</html>
