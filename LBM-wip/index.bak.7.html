<!DOCTYPE HTML>
<html>
<head>
<link href = 'https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel = 'stylesheet' type = 'text/css'>
<style>
html, body {
	margin: 0; padding: 0;
	background-color: #fff;
	color: #999;

	font-family: 'open sans', sans-serif;
	font-size: 14px;
}
h2 { font-size: 18px; }

/*UI*/

#container {
	width: 720px;
	margin: 4px auto;
}
#credits{
	margin-top: 16px;
	font-size: 12px;
}

/* WORLD*/

#world {
	border: 1px #ccc none;/*dashed;*/

	margin: 4px auto;

	position: relative;

	width: 512px;
	height: 512px;

	image-rendering: pixelated;
	/*overflow: hidden;*/
}

</style>

</head>
<body>

<div id = "container">
	<h2>TITLE</h2>

	<canvas id = "world" width = "512" height = "512"></canvas>

	<script id = "vsh" type = "text/GLSL">#version 300 es
	precision mediump float;

	in vec2 vert_x;

	void main ()
	{
		gl_Position = vec4(vert_x, 0., 1.);
	}
	</script>

	<script id = "fsh" type = "text/GLSL">#version 300 es
	precision mediump float;

	uniform sampler2D tex;

	out vec4 frag_color;

	/* lattice vectors & weights */
	vec2 e[9];
	float w[9] = float[](
		4./9.,
		1./9., 1./9., 1./9., 1./9.,
		1./36.,	1./36., 1./36.,	1./36.);

	/* flag */
	float unstable = 0.0;
	float flag = 0.0; 

	vec4 texel(sampler2D tx, ivec2 frag) {
		return texture(tx, vec2(frag)/512.);
	}

	ivec2 frag_to_lab (ivec2 frag) {
		return frag/2;
	}
	ivec2 lab_to_frag (ivec2 lab, int celltype) {
		return lab*2+ivec2((celltype&2)/2, celltype&1);
	}

	float f_prev (int component, ivec2 lab) {
		return texel(
			tex,
			lab_to_frag(
				lab,
				component%3
			))[component/3];
	}

	float f_equi (int component, float rh, vec2 u) {
		int i = component;
		float eiu = dot(u, e[i]);
		float feq =  w[i]*rh*(1.0 +
			3.0*eiu + 4.5*eiu*eiu - 1.5*dot(u, u));
		if (!(feq >= 0.0)) { flag = 1.0; }
		return feq;
	}

	bool boundary (ivec2 lab) {
		return distance(vec2(lab), vec2(60, 128)) < 10.;
		//return abs(lab.x-60) < 4 && abs(lab.y - 128) < 4;
	}

	void main ()
	{

		ivec2 frag = ivec2(gl_FragCoord.xy);
		ivec2 lab = frag_to_lab(frag);

		int celltype = 2*(frag.x&1) + (frag.y&1);

		e[0] = vec2( 0,  0); e[1] = vec2( 1,  0); e[2] = vec2( 0,  1);
		e[3] = vec2(-1,  0); e[4] = vec2( 0, -1); e[5] = vec2( 1,  1);
		e[6] = vec2(-1,  1); e[7] = vec2(-1, -1); e[8] = vec2( 1, -1);

		int inv[9] = int[](0, 3, 4, 1, 2, 7, 8, 5, 6);

		/* streaming step */
		float f[9];
		for (int i = 0; i < 9; ++i) {
			if (boundary(lab - ivec2(e[i]))) {
				f[i] = f_prev(inv[i], lab);
			} else {
				f[i] = f_prev(i, lab - ivec2(e[i]));
			}
		}
		if (boundary(lab)) {
			for (int i = 0; i < 9; ++i) { f[i] = 0.0; }
		}

		/* equilibium */
		float rho = 0.0;
		vec2 u = vec2(0.0, 0);
		for (int i = 0; i < 9; ++i) {
			rho = rho + f[i];
			u = u + f[i]*e[i];
		}
		u = mix(u/rho, vec2(0., 0.), float(rho == 0.));

		/* relaxation */
		float omega = 1.9;
		for (int i = 0; i < 9; ++i) {
			f[i] = f[i] * (1.0 - omega) + omega * f_equi(i, rho, u);
			if (!(f[i] >= 0.0)) { unstable = 1.0; }
		}

		/* sources and stuff */
		if (lab.x == 0) {
		for (int i = 0; i < 9; ++i) {
			f[i] = f_equi(i, 1.0, vec2(0.1, 0.002));
		}}

		/* write results */
		if (celltype % 4 != 3) {
		frag_color = vec4(
			f[celltype%4],
			f[celltype%4+3],
			f[celltype%4+6],
			1);
		} else {
			frag_color = vec4(u.y*-10., 0., u.y*10., 1);
		}
	}
	</script>

	<script src = "gl.js"></script>
	<script>

		var g = new GL(document.getElementById("world"));
		g.makeShader("v", document.getElementById("vsh").text, g.gl.VERTEX_SHADER);
		g.makeShader("f", document.getElementById("fsh").text, g.gl.FRAGMENT_SHADER);
		g.makeProgram("p", g.sh.v, g.sh.f);


		/* set up vertex buffer */
		const vert_x = new Float32Array([ 1, 1, -1, 1, 1, -1, -1, -1 ]);
		g.makeAttributeBuffer(g.prg.p, "vert_x", 2, g.gl.FLOAT);
		g.setAttributeBuffer(g.prg.p, "vert_x", vert_x);

		/* set up textures */
		const w_width = 512;
		const tex_A = new Float32Array(w_width*w_width*4);
		for (let i = 0; i < w_width*w_width*4; ++i) { tex_A[i] = 0;	}

		function set_f_eq(arr, i, j, rho) {
			let w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];

			let f = [];
			for (let c = 0; c < 9; ++c) {
				f[c] = rho * w[c];
			}

			for (let c = 0; c < 9; ++c) {
				let x = 2*i + (c%3 == 2 ? 1 : 0);
				let y = 2*j + (c%3 == 1 ? 1 : 0);
				let cl = Math.floor(c/3);
				arr[(x+w_width*y)*4+cl] = f[c];
			}
		}

		for (let i = 0; i < w_width/2; ++i) {
		for (let j = 0; j < w_width/2; ++j) {
			set_f_eq(tex_A, i, j, 1.0);
		}}


	

		g.makeTexture("tex_A");
		g.setTexture("tex_A", tex_A, w_width, g.gl.RGBA32F, g.gl.RGBA, g.gl.FLOAT);

		g.makeSampler(g.prg.p, "tex", "1i");
		g.setSampler(g.prg.p, "tex", "tex_A");

		g.gl.activeTexture(g.gl.TEXTURE1);
		g.gl.bindTexture(g.gl.TEXTURE_2D, g.tex["tex_A"]);

		/* set up framebuffers */
		g.makeFramebuffer("fb_A", w_width, g.gl.RGBA32F, g.gl.RGBA, g.gl.FLOAT);
		g.makeFramebuffer("fb_B", w_width, g.gl.RGBA32F, g.gl.RGBA, g.gl.FLOAT);

		/* render first timestep into fb_A */
		g.renderToFramebuffer(g.prg.p, g.gl.TRIANGLE_STRIP, g.fb["fb_A"]);
		g.render(g.prg.p, g.gl.TRIANGLE_STRIP);

		let t = 0; let dt = 0.01;
		function timestep (t)
		{
			g.setSampler(g.prg.p, "tex", "_tex-fb_A");
			g.renderToFramebuffer(g.prg.p, g.gl.TRIANGLE_STRIP, g.fb["fb_B"]);

			g.setSampler(g.prg.p, "tex", "_tex-fb_B");
			g.renderToFramebuffer(g.prg.p, g.gl.TRIANGLE_STRIP, g.fb["fb_A"]);

			g.render(g.prg.p, g.gl.TRIANGLE_STRIP);

			window.requestAnimationFrame(timestep);
		}

		timestep();



	</script>
	
	<div><p>description.</p></div>

	<div id = "credits">
	J. Lok, [M] [yyyy].
	</div>

</div>


</body>

</html>
