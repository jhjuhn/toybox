<!DOCTYPE HTML>
<html>
<head>
<link href = 'https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel = 'stylesheet' type = 'text/css'>
<style>
html, body {
	margin: 0; padding: 0;
	background-color: #000;
	color: #999;

	font-family: 'open sans', sans-serif;
	font-size: 14px;
}
h2 { font-size: 18px; }

/*UI*/

#container {
	width: 720px;
	margin: 4px auto;
}
#credits{
	margin-top: 16px;
	font-size: 12px;
}

/* WORLD*/

#world {
	border: 1px #ccc none;/*dashed;*/

	margin: 4px auto;

	position: relative;

	width: 512px;
	height: 512px;

	image-rendering: pixelated;
	/*overflow: hidden;*/
}

</style>

</head>
<body>

<div id = "container">
	<h2>TITLE</h2>

	<canvas id = "world" width = "512" height = "512"></canvas>

	<script id = "vsh" type = "text/GLSL">#version 300 es
	precision mediump float;

	in vec2 vert_x;

	void main ()
	{
		gl_Position = vec4(vert_x, 0., 1.);
	}
	</script>

	<script id = "fsh-sim" type = "text/GLSL">#version 300 es
	precision mediump float;

	uniform sampler2D tex;

	out vec4 frag_color;

	/* lattice vectors & weights */
	vec2 e[9];
	float w[9] = float[](
		4./9.,
		1./9., 1./9., 1./9., 1./9.,
		1./36.,	1./36., 1./36.,	1./36.);

	/* flag */
	float flag = 0.0; 

	vec4 texel(sampler2D tx, ivec2 frag) {
		return texture(tx, vec2(frag)/512.);
	}

	ivec2 frag_to_lab (ivec2 frag) {
		return frag/2;
	}
	ivec2 lab_to_frag (ivec2 lab, int celltype) {
		return lab*2+ivec2((celltype&2)/2, celltype&1);
	}

	float f_prev (int component, ivec2 lab) {
		return texel(
			tex,
			lab_to_frag(
				lab,
				component%3
			))[component/3];
	}

	float f_equi (int component, float rh, vec2 u) {
		int i = component;
		float eiu = dot(u, e[i]);
		float feq =  w[i]*rh*(1.0 +
			3.0*eiu + 4.5*eiu*eiu - 1.5*dot(u, u));
		if (!(feq >= 0.0)) { flag = 1.0; }
		return feq;
	}

	bool boundary (ivec2 lab) {
		//return distance(vec2(lab), vec2(60, 128)) < 12.;
		return abs(lab.x-60) < 6 && abs(lab.y - 128) < 18;
	}

	void main ()
	{

		ivec2 frag = ivec2(gl_FragCoord.xy);
		ivec2 lab = frag_to_lab(frag);

		int celltype = 2*(frag.x&1) + (frag.y&1);

		e[0] = vec2( 0,  0); e[1] = vec2( 1,  0); e[2] = vec2( 0,  1);
		e[3] = vec2(-1,  0); e[4] = vec2( 0, -1); e[5] = vec2( 1,  1);
		e[6] = vec2(-1,  1); e[7] = vec2(-1, -1); e[8] = vec2( 1, -1);

		int inv[9] = int[](0, 3, 4, 1, 2, 7, 8, 5, 6);

		/* streaming step */
		float f[12]; /* 9, 10, and 11 are rho, u.x, and u.y */
		for (int i = 0; i < 9; ++i) {
			f[i] = mix(
				f_prev(i, lab - ivec2(e[i])),
				f_prev(inv[i], lab),
				boundary(lab-ivec2(e[i])));
			f[i] *= (1. - float(boundary(lab)));
		}

		/* equilibium */
		float rho = 0.0;
		vec2 u = vec2(0.0, 0);
		for (int i = 0; i < 9; ++i) {
			rho += f[i];
			u += f[i]*e[i];
		}
		u = mix(u/rho, vec2(0., 0.), float(rho == 0.));

		f[9] = rho; f[10] = u.x; f[11] = u.y;

		/* relaxation */
		float omega = 1.9;
		for (int i = 0; i < 9; ++i) {
			f[i] = f[i] * (1.0 - omega) + omega * f_equi(i, rho, u);
		}

		/* sources and stuff */
		if (lab.x == 0) {
		for (int i = 0; i < 9; ++i) {
			f[i] = f_equi(i, 1.0, vec2(0.1, 0.00001));
		}}

		/* write results; don't care about celltype 3 */
		if (celltype == 3) {
			frag_color = vec4(0, u.x*4., u.y*4., 1);
		} else {
		frag_color = vec4(
			f[celltype%4],
			f[celltype%4+3],
			f[celltype%4+6],
			f[celltype%4+9]);
		}
	}
	</script>
	<script id = "fsh-img", type = "text/GLSL">#version 300 es
		precision mediump float;

		uniform sampler2D tex;

		out vec4 frag_color;


		vec4 texel(sampler2D tx, ivec2 frag) {
			return texture(tx, vec2(frag)/512.);
		}

		ivec2 frag_to_lab (ivec2 frag) {
			return frag/2;
		}
		ivec2 lab_to_frag (ivec2 lab, int celltype) {
			return lab*2+ivec2((celltype&2)/2, celltype&1);
		}

		float f (int component, ivec2 lab) {
			return texel(
				tex,
				lab_to_frag(
					lab,
					component%3
				))[component/3];
		}

		float vort (ivec2 lab) {
			/* vorticity by central difference */
			return 0.5*(f(11, lab+ivec2(1, 0))-f(11, lab-ivec2(1, 0))) -
			0.5*(f(10, lab+ivec2(0, 1))-f(10, lab-ivec2(0, 1)));
		}

		float umag (ivec2 lab) {
			return length(vec2(f(10, lab), f(11, lab)));
		}

		/* colour space conversion */
		vec3 hsv2rgb(vec3 c) {
		  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
		  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
		  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
		}

		vec4 palette (float s) {
			return vec4(abs(s), abs(s), abs(s), 1.);
		}

		void main()
		{
			ivec2 lab = frag_to_lab(ivec2(gl_FragCoord.xy));

			//frag_color = texture(tex, gl_FragCoord.xy/512.);
			float rho = f(9, lab);
			float v = vort(lab);

			frag_color = palette(v*20.);
		}
	</script>

	<script src = "gl.js"></script>
	<script>

		var g = new GL(document.getElementById("world"));
		g.makeShader("v", document.getElementById("vsh").text, g.gl.VERTEX_SHADER);
		g.makeShader("fsim", document.getElementById("fsh-sim").text, g.gl.FRAGMENT_SHADER);
		g.makeShader("fimg", document.getElementById("fsh-img").text, g.gl.FRAGMENT_SHADER);

		g.makeProgram("psim", g.sh.v, g.sh.fsim);
		g.makeProgram("pimg", g.sh.v, g.sh.fimg);


		/* set up vertex buffer */
		const vert_x = new Float32Array([ 1, 1, -1, 1, 1, -1, -1, -1 ]);

		g.makeAttributeBuffer(g.prg.psim, "vert_x", 2, g.gl.FLOAT);
		g.setAttributeBuffer(g.prg.psim, "vert_x", vert_x);

		g.makeAttributeBuffer(g.prg.pimg, "vert_x", 2, g.gl.FLOAT);
		g.setAttributeBuffer(g.prg.pimg, "vert_x", vert_x);

		/* set up textures */
		const w_width = 512;
		const tex_A = new Float32Array(w_width*w_width*4);
		for (let i = 0; i < w_width*w_width*4; ++i) { tex_A[i] = 0;	}

		function set_f_eq(arr, i, j, rho) {
			let w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];

			let f = [];
			for (let c = 0; c < 9; ++c) {
				f[c] = rho * w[c];
			}

			for (let c = 0; c < 9; ++c) {
				let x = 2*i + (c%3 == 2 ? 1 : 0);
				let y = 2*j + (c%3 == 1 ? 1 : 0);
				let cl = Math.floor(c/3);
				arr[(x+w_width*y)*4+cl] = f[c];
			}
		}

		for (let i = 0; i < w_width/2; ++i) {
		for (let j = 0; j < w_width/2; ++j) {
			set_f_eq(tex_A, i, j, 1.0);
		}}

		g.makeTexture("tex_A");
		g.setTexture("tex_A", tex_A, w_width, g.gl.RGBA32F, g.gl.RGBA, g.gl.FLOAT);

		g.makeSampler(g.prg.psim, "tex");
		g.setSampler(g.prg.psim, "tex", "tex_A");

		g.makeSampler(g.prg.pimg, "tex");
		g.setSampler(g.prg.pimg, "tex", "tex_A");

		g.gl.activeTexture(g.gl.TEXTURE1);
		g.gl.bindTexture(g.gl.TEXTURE_2D, g.tex["tex_A"]);

		/* set up framebuffers */
		g.makeFramebuffer("fb_A", w_width, g.gl.RGBA32F, g.gl.RGBA, g.gl.FLOAT);
		g.makeFramebuffer("fb_B", w_width, g.gl.RGBA32F, g.gl.RGBA, g.gl.FLOAT);

		/* render first timestep into fb_A */
		g.renderToFramebuffer(g.prg.psim, g.gl.TRIANGLE_STRIP, g.fb["fb_A"]);
		g.render(g.prg.psim, g.gl.TRIANGLE_STRIP);

		let t = 0; let prev_t = 0;
		function timestep (t)
		{
			//console.log(t - prev_t); prev_t = t;

			for (let i = 0; i < 4; ++i) {
				g.setSampler(g.prg.psim, "tex", "_tex-fb_A");
				g.renderToFramebuffer(g.prg.psim, g.gl.TRIANGLE_STRIP, g.fb["fb_B"]);

				g.setSampler(g.prg.psim, "tex", "_tex-fb_B");
				g.renderToFramebuffer(g.prg.psim, g.gl.TRIANGLE_STRIP, g.fb["fb_A"]);
			}

			g.setSampler(g.prg.pimg, "tex", "_tex-fb_B");
			g.render(g.prg.pimg, g.gl.TRIANGLE_STRIP);

			window.requestAnimationFrame(timestep);
		}

		window.requestAnimationFrame(timestep);



	</script>
	
	<div><p>description.</p></div>

	<div id = "credits">
	J. Lok, [M] [yyyy].
	</div>

</div>


</body>

</html>
