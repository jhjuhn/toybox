<!DOCTYPE HTML>
<html>
<head>
<link href = 'https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel = 'stylesheet' type = 'text/css'>
<style>
html, body {
	margin: 0; padding: 0;
	background-color: #fff;
	color: #0af;

	font-family: 'open sans', sans-serif;
	font-size: 14px;
}
h2 {
	font-size: 18px;
	color: #fc6;
}

/*UI*/

#container {
	width: 720px;
	margin: 4px auto;
}
#credits{
	margin-top: 16px;
	font-size: 12px;
}

/* WORLD*/

#world {
	border: 1px #ccc none;/*dashed;*/

	margin: 4px auto;

	position: relative;

	width: 720px;
	height: 720px;

	image-rendering: pixelated;
	/*overflow: hidden;*/
}

</style>

</head>
<body>

<div id = "container">
	<h2>LATTICE BOLTZMANN, IN PARALLEL</h2>

	<canvas id = "world" width = "512" height = "512"></canvas>

	<script id = "vsh" type = "text/GLSL">#version 300 es
	precision mediump float;

	in vec2 vert_x;

	void main ()
	{
		gl_Position = vec4(vert_x, 0., 1.);
	}
	</script>

	<script id = "fsh-sim" type = "text/GLSL">#version 300 es
	precision mediump float;

	uniform sampler2D tex;

	uniform vec2 cursor;
	uniform float radius;

	out vec4 frag_color;

	/* lattice vectors & weights */
	vec2 e[9];
	float w[9] = float[](
		4./9.,
		1./9., 1./9., 1./9., 1./9.,
		1./36.,	1./36., 1./36.,	1./36.);

	/* flag */
	float flag = 0.0; 

	vec4 texel(sampler2D tx, ivec2 frag) {
		return texture(tx, vec2(frag)/512.);
	}

	ivec2 frag_to_lab (ivec2 frag) {
		return frag/2;
	}
	ivec2 lab_to_frag (ivec2 lab, int celltype) {
		return lab*2+ivec2((celltype&2)/2, celltype&1);
	}

	float f_prev (int component, ivec2 lab) {
		return texel(
			tex,
			lab_to_frag(
				lab,
				component%3
			))[component/3];
	}

	float f_equi (int component, float rh, vec2 u) {
		int i = component;
		float eiu = dot(u, e[i]);
		float feq =  w[i]*rh*(1.0 +
			3.0*eiu + 4.5*eiu*eiu - 1.5*dot(u, u));
		if (!(feq >= 0.0)) { flag = 1.0; }
		return feq;
	}

	bool boundary (ivec2 lab) {
		//return distance(vec2(lab), vec2(60, 128)) < 12.;
		return abs(lab.x-50) < 6 && abs(lab.y - 128) < 18 ||
		distance(vec2(lab), cursor) < radius;
	}

	void main ()
	{

		ivec2 frag = ivec2(gl_FragCoord.xy);
		ivec2 lab = frag_to_lab(frag);

		int celltype = 2*(frag.x&1) + (frag.y&1);

		e[0] = vec2( 0,  0); e[1] = vec2( 1,  0); e[2] = vec2( 0,  1);
		e[3] = vec2(-1,  0); e[4] = vec2( 0, -1); e[5] = vec2( 1,  1);
		e[6] = vec2(-1,  1); e[7] = vec2(-1, -1); e[8] = vec2( 1, -1);

		int inv[9] = int[](0, 3, 4, 1, 2, 7, 8, 5, 6);

		/* streaming step */
		float f[12]; /* 9, 10, and 11 are rho, u.x, and u.y */
		for (int i = 0; i < 9; ++i) {
			f[i] = mix(
				f_prev(i, lab - ivec2(e[i])),
				f_prev(inv[i], lab),
				boundary(lab-ivec2(e[i])));

			f[i] = mix(f[i], w[i], float(boundary(lab)));
		}

		/* equilibium */
		float rho = 0.0;
		vec2 u = vec2(0.0, 0);
		for (int i = 0; i < 9; ++i) {
			rho += f[i];
			u += f[i]*e[i];
		}
		u = mix(u/rho, vec2(0., 0.), float(rho == 0.));

		f[9] = rho; f[10] = u.x; f[11] = u.y;

		/* relaxation */
		float omega = 1.8;
		for (int i = 0; i < 9; ++i) {
			f[i] = f[i] * (1.0 - omega) + omega * f_equi(i, rho, u);

			/* hide your instabilities */
			f[i] = mix(f[i], w[i], float(f[i] < 0.));
		}

		/* sources and stuff */
		if (lab.x == 0) {
		for (int i = 0; i < 9; ++i) {
			f[i] = f_equi(i, 1.0, vec2(0.1, 0.00001));
		}}

		/* write results; don't care about celltype 3 */
		frag_color = vec4(
			f[celltype%4],
			f[celltype%4+3],
			f[celltype%4+6],
			f[celltype%4+9]);
	}
	</script>
	<script id = "fsh-img", type = "text/GLSL">#version 300 es
		precision mediump float;

		uniform sampler2D tex;

		uniform vec2 cursor;
		uniform float radius;

		out vec4 frag_color;

		vec4 texel(sampler2D tx, ivec2 frag) {
			return texture(tx, vec2(frag)/512.);
		}

		ivec2 frag_to_lab (ivec2 frag) {
			return frag/2;
		}
		ivec2 lab_to_frag (ivec2 lab, int celltype) {
			return lab*2+ivec2((celltype&2)/2, celltype&1);
		}

		float f (int component, ivec2 lab) {
			return texel(
				tex,
				lab_to_frag(
					lab,
					component%3
				))[component/3];
		}

		float vort (ivec2 lab) {
			/* vorticity by central difference */
			return (0.5*(f(11, lab+ivec2(1, 0))-f(11, lab-ivec2(1, 0))) -
			0.5*(f(10, lab+ivec2(0, 1))-f(10, lab-ivec2(0, 1))));
		}

		vec4 scale (float s) {
			/* NaN - respecting clamp */
			s = 2.0 * float(s > 2.) +
			(-2.0) * float(s < -2.) +
			s*float((s < 2.) && (s > -2.));

			float c = sin(s);
			return vec4(1.-c, 1.-0.2*abs(c), 1.+c, 1.);
		}

		bool boundary (ivec2 lab) {
			return abs(lab.x-50) < 4 && abs(lab.y - 128) < 16 ||
			distance(vec2(lab), cursor) < radius-2.;
		}

		void main()
		{
			ivec2 lab = frag_to_lab(ivec2(gl_FragCoord.xy));

			float rho = 3.*(f(9, lab)-1.);
			float v = vort(lab)*30.;

			/* grey if part of obstable, white if border (vorticity
			 * data doesn't make sense there), colour by vorticity
			 * otherwise. */
			bool b = boundary(lab);
			frag_color = mix(
				scale(v),
				vec4(1., 1., 1., 1.) - float(b)*vec4(0.1, 0.1, 0.1, 0.0),
				float((lab.x == 0) || (lab.x == 255) || b));
		}
	</script>

	<script src = "gl.js"></script>
	<script>

		var g = new GL(document.getElementById("world"));
		g.makeShader("v", document.getElementById("vsh").text, g.gl.VERTEX_SHADER);
		g.makeShader("fsim", document.getElementById("fsh-sim").text, g.gl.FRAGMENT_SHADER);
		g.makeShader("fimg", document.getElementById("fsh-img").text, g.gl.FRAGMENT_SHADER);

		g.makeProgram("psim", g.sh.v, g.sh.fsim);
		g.makeProgram("pimg", g.sh.v, g.sh.fimg);


		/* set up vertex buffer */
		const vert_x = new Float32Array([ 1, 1, -1, 1, 1, -1, -1, -1 ]);

		g.makeAttributeBuffer(g.prg.psim, "vert_x", 2, g.gl.FLOAT);
		g.setAttributeBuffer(g.prg.psim, "vert_x", vert_x);

		g.makeAttributeBuffer(g.prg.pimg, "vert_x", 2, g.gl.FLOAT);
		g.setAttributeBuffer(g.prg.pimg, "vert_x", vert_x);

		/* set up textures */
		const w_width = 512;
		const tex_A = new Float32Array(w_width*w_width*4);
		for (let i = 0; i < w_width*w_width*4; ++i) { tex_A[i] = 0;	}

		function set_f_eq(arr, i, j, rho) {
			let w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];

			let f = [];
			for (let c = 0; c < 9; ++c) {
				f[c] = rho * w[c];
			}

			for (let c = 0; c < 9; ++c) {
				let x = 2*i + (c%3 == 2 ? 1 : 0);
				let y = 2*j + (c%3 == 1 ? 1 : 0);
				let cl = Math.floor(c/3);
				arr[(x+w_width*y)*4+cl] = f[c];
			}
		}

		for (let i = 0; i < w_width/2; ++i) {
		for (let j = 0; j < w_width/2; ++j) {
			set_f_eq(tex_A, i, j, 1.0);
		}}

		g.makeTexture("tex_A");
		g.setTexture("tex_A", tex_A, w_width, g.gl.RGBA32F, g.gl.RGBA, g.gl.FLOAT);

		/* interaction */
		let interact = 0;
		let cursor = [ 120, 120 ];
		let radius = 10;

		g.makeUniform(g.prg.psim, "cursor", "2fv");
		g.setUniform(g.prg.psim, "cursor", new Float32Array(cursor));

		g.makeUniform(g.prg.psim, "radius", "1f");
		g.setUniform(g.prg.psim, "radius", radius);

		g.makeUniform(g.prg.pimg, "cursor", "2fv");
		g.setUniform(g.prg.pimg, "cursor", new Float32Array(cursor));

		g.makeUniform(g.prg.pimg, "radius", "1f");
		g.setUniform(g.prg.pimg, "radius", radius);

		window.addEventListener('wheel', function (e) {
			if (e.deltaY < 0) {
				radius = Math.min(40, radius + 1);
			} else {
				radius = Math.max(3, radius - 1);
			}
		});
		window.addEventListener('mousedown',	function (e) { interact = 1;  });
		window.addEventListener('mouseup',		function (e) { interact = 0; });

		window.addEventListener('mousemove', function (e) {
			let rect = g.canv.getBoundingClientRect();
			cursor[0] = (e.clientX - rect.left) * 256 / 720;
			cursor[1] = (720 - (e.clientY - rect.top)) * 256 / 720;
		});


		g.makeSampler(g.prg.psim, "tex");
		g.setSampler(g.prg.psim, "tex", "tex_A");

		g.makeSampler(g.prg.pimg, "tex");
		g.setSampler(g.prg.pimg, "tex", "tex_A");

		g.gl.activeTexture(g.gl.TEXTURE1);
		g.gl.bindTexture(g.gl.TEXTURE_2D, g.tex["tex_A"]);

		/* set up framebuffers */
		g.makeFramebuffer("fb_A", w_width, g.gl.RGBA32F, g.gl.RGBA, g.gl.FLOAT);
		g.makeFramebuffer("fb_B", w_width, g.gl.RGBA32F, g.gl.RGBA, g.gl.FLOAT);

		/* render first timestep into fb_A */
		g.renderToFramebuffer(g.prg.psim, g.gl.TRIANGLE_STRIP, g.fb["fb_A"]);
		g.render(g.prg.psim, g.gl.TRIANGLE_STRIP);

		let t = 0; let prev_t = 0;
		function timestep (t)
		{
			if (interact) {
			g.setUniform(g.prg.psim, "cursor", new Float32Array(cursor));
			g.setUniform(g.prg.pimg, "cursor", new Float32Array(cursor));
			}
			g.setUniform(g.prg.psim, "radius", radius*interact);
			g.setUniform(g.prg.pimg, "radius", radius*interact);

			for (let i = 0; i < 4; ++i) {
				g.setSampler(g.prg.psim, "tex", "_tex-fb_A");
				g.renderToFramebuffer(g.prg.psim, g.gl.TRIANGLE_STRIP, g.fb["fb_B"]);

				g.setSampler(g.prg.psim, "tex", "_tex-fb_B");
				g.renderToFramebuffer(g.prg.psim, g.gl.TRIANGLE_STRIP, g.fb["fb_A"]);
			}

			g.setSampler(g.prg.pimg, "tex", "_tex-fb_B");
			g.render(g.prg.pimg, g.gl.TRIANGLE_STRIP);

			window.requestAnimationFrame(timestep);
		}

		window.requestAnimationFrame(timestep);



	</script>
	
	<div><p>D2Q9 Lattice Gas Boltzmann simulation exhibiting vortex shedding. Timestepping is done in a GLSL fragment shader, in which all cells are updated in parallel. The flow field, 256 by 256 grid cells in dimension, is coloured by vorticity.</p>

	<p>Interact with the simulation by holding down a mouse button, moving the cursor, and scrolling.</p>
	</div>

	<div id = "credits">
	J. Lok, May 2018.
	</div>

</div>


</body>

</html>
