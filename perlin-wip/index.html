<!DOCTYPE HTML>
<html>
<head>
<title>Divergence-Free Flow Fields</title>
<link href = 'https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel = 'stylesheet' type = 'text/css'>
<style>
html, body {
	margin: 0; padding: 0;
	background-color: #000;
	color: #611;

	font-family: 'open sans', sans-serif;
	font-size: 14px;
}
h2 { font-size: 18px; }

/*UI*/

#container {
	width: 720px;
	margin: 4px auto;
}
#credits{
	margin-top: 16px;
	font-size: 12px;
}

/* WORLD*/
#world {
	border: 1px #ccc none;/*dashed;*/

	margin: 4px auto;

	position: relative;

	width: 720;
	height: 720;

	image-rendering: pixelated;
	/*overflow: hidden;*/
}

</style>

<script id = "v_quad" type = "text/glsl">#version 300 es
in vec2 x; void main() { gl_Position = vec4(x, 0., 1.); }
</script>

<!-- draws particles at position according to data texture -->
<script id = "v_img" type = "text/glsl">#version 300 es
uniform sampler2D dat;
in vec2 ij;

out float age;
out float v;
out vec2 x;

void main() {
	vec4 col = texelFetch(dat, ivec2(ij), 0);

	x = col.xy;
	v = col.w;
	age = col.z;

	gl_Position = vec4(x, 0., 1.);
}

</script>

<!-- specifies the colour of particles -->
<script id = "f_img" type = "text/glgl">#version 300 es
precision mediump float;

in float age;
in vec2 x;
in float v;

out vec4 frag_colour;

vec4 scheme (float t) {
	t = min(t, .8);
	vec3 a = vec3(.8, .5, .4);
	vec3 b = vec3(.2, .4, .2);
	vec3 c = vec3(2., 1., 1.);
	vec3 d = vec3(.0, .3, .25);
	return vec4(a + b*cos(6.28*(c*t+d)), 1.);
}

void main () {
	float scale = sqrt(v)*12.;
	frag_colour = scheme(scale);
}
</script>

<!-- renders a faded copy of a previous frame -->
<script id = "f_fade" type = "text/glsl">#version 300 es
precision mediump float;

uniform sampler2D prev;
uniform float trail;

out vec4 frag_colour;
void main() {
	vec4 bg = vec4(0., 0., 0., 1.);
	frag_colour = mix(
		texelFetch(prev, ivec2(gl_FragCoord.xy), 0),
		bg, 1.-trail)-2e-3;
	frag_colour = max(frag_colour, bg);
}
</script>

<!-- integrate particle positions & write to data texture -->
<script id = "f_step" type = "text/glsl">#version 300 es
#define M 720.;
precision mediump float;

uniform sampler2D prev;
uniform float time;

uniform float max_age;
uniform int octave;

out vec4 frag_colour;

/* functions & consts for noise field generation */

const vec3 grad[12] = vec3[12](
	vec3( 1., 1., 0.), vec3( 1., 0., 1.), vec3( 0., 1., 1.),
	vec3( 1.,-1., 0.), vec3( 1., 0.,-1.), vec3( 0., 1.,-1.),
	vec3(-1., 1., 0.), vec3(-1., 0., 1.), vec3( 0.,-1., 1.),
	vec3(-1.,-1., 0.), vec3(-1., 0.,-1.), vec3( 0.,-1.,-1.)
);

const vec3 offset[8] = vec3[8](
	vec3(0., 0., 0.), vec3(0., 0., 1.), vec3(0., 1., 0.), vec3(0., 1., 1.),
	vec3(1., 0., 0.), vec3(1., 0., 1.), vec3(1., 1., 0.), vec3(1., 1., 1.)
);

vec3 terp(vec3 t) { return t*t*t*(t*(t*6.-15.)+10.);	}
vec3 bump(vec3 t) { return t*t*(t*(t*30.-60.)+30.);		}
vec3 bimp(vec3 t) { return t*t*t*(t*(t*36.-75.)+40.);	}

vec3 grad_lookup(vec3 st) {
    return grad[int(fract(sin(dot(st,
	vec3(12.9898, 40.931, 78.233)))
	*43758.5453123)*12.)];
}

vec2 field (vec3 co, float gridsize) {

	co = co/gridsize;
	vec3 gridco = floor(co);
	vec3 f = co - vec3(gridco);

	vec3 w = terp(f);
	vec3 dw = bump(f);
	vec3 dw2 = bimp(f);

	vec3 g[4];
	for (int i = 0; i < 4; ++i) {
		g[i] = mix(
		grad_lookup(gridco+offset[2*i  ]),
		grad_lookup(gridco+offset[2*i+1]), f.z);
	}
	vec4 g1 = vec4(g[0].xy, g[1].xy);
	vec4 g2 = vec4(g[2].xy, g[3].xy);

	/* ugly closed-form gradient */
	return vec2(
	((g[0].y + (g[2].y-g[0].y)*w.x) + ((g[1].x-g[0].x)*f.x - g[1].y +
	((g[0].x-g[2].x-g[1].x+g[3].x)*f.x + g[2].x + g[1].y - g[3].x - g[3].y)*w.x)*dw.y +
	((g[1].y-g[0].y) + (g[0].y-g[2].y-g[1].y+g[3].y)*w.x)*dw2.y)*-1.,
	((g[0].x + (g[1].x-g[0].x)*w.y) + ((g[2].y-g[0].y)*f.y - g[2].x +
	((g[0].y-g[2].y-g[1].y+g[3].y)*f.y + g[2].x + g[1].y - g[3].x - g[3].y)*w.y)*
	dw.x + ((g[2].x-g[0].x) + (g[0].x-g[2].x-g[1].x+g[3].x)*w.y)*dw2.x)*1.);
}

float random (vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123) +
	sin(199.73*time)*0.05;
}
void main () {
	vec4 info = texelFetch(prev, ivec2(gl_FragCoord.xy), 0);

	vec2 xy = info.xy;
	float age = info.z;

	float oct[5];
	int p2 = 1;
	for (int i = 0; i < 5; ++i) {
		oct[i] = float(octave & p2) / float(p2);
		p2 *= 2;
	}

	vec2 v = 0.004*((
	oct[0]*field(vec3(xy, time/12.), 0.0625)+
	oct[1]*field(vec3(xy, time/17.), 0.125)+
	oct[2]*field(vec3(xy, time/24.), 0.25)+
	oct[3]*field(vec3(xy, time/34.), 0.5)+
	oct[4]*field(vec3(xy, time/48.), 1.0)))/(log(float(octave))+1.);

	xy += v;
	age += 1./max_age;

	if (age > 1.) {
		xy = vec2(
			random(vec2(xy.x, xy.y))*2. - 1.,
			random(vec2(xy.y, xy.x))*2. - 1.
		);
		age = 0.;
	}
	//xy = mod(xy+1., 2.)-1.;

	frag_colour = vec4(xy, age, length(v));
}
</script>

</head>
<body>

<div id = "container">
	<h2>DIVERGENCE-FREE FLOW FIELDS</h2>

	<canvas id = "world" width = "720" height = "720"></canvas>
	<script>
		const canv = document.getElementById("world");
		const gl = canv.getContext("webgl2");

		if (!gl) {
			throw "error: webgl2 not supported.";
		}

		const ext = gl.getExtension("EXT_color_buffer_float");
		if (!ext) {
			throw "error: rendering to float texture not supported.";
		}

	
		function makeShader (gl, src, type) {
			const sh = gl.createShader(type);
			gl.shaderSource(sh, src);
			gl.compileShader(sh);
			if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
				throw "error compiling shader: " +
				gl.getShaderInfoLog(sh);
			}
			return sh;
		}

		function makeProgram (gl, vsh, fsh) {
			const prg = gl.createProgram();
			gl.attachShader(prg, vsh);
			gl.attachShader(prg, fsh);
			gl.linkProgram(prg);
			if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
				throw "error linking program: " +
				gl.getProgramInfoLog(prg);
			}
			return prg;
		}

		function makeTexture (gl, texunit, fi, w, h, f, type, data, minf, magf, ws, wt) {
			const tex = gl.createTexture();
			gl.activeTexture(gl["TEXTURE"+texunit]);
			gl.bindTexture(gl.TEXTURE_2D, tex);
			gl.texImage2D(gl.TEXTURE_2D, 0, fi, w, h, 0, f, type, data);

			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minf);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magf);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, ws);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wt);

			return tex;
		}

		function makeFramebuffer (gl, tex, texunit) {
			const fbf = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbf);

			gl.activeTexture(gl["TEXTURE"+texunit]);

			gl.framebufferTexture2D(gl.FRAMEBUFFER,
			gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);

			return fbf;
		}

		function makeBuffer (gl, data, drawtype) {
			const buf = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, buf);
			gl.bufferData(gl.ARRAY_BUFFER, data, drawtype);

			return buf;
		}

		function setBuffer(gl, prg, buf, loc, batch, type) {
			if (prg) { gl.useProgram(prg); }
			gl.bindBuffer(gl.ARRAY_BUFFER, buf);

			gl.enableVertexAttribArray(loc);
			gl.vertexAttribPointer(loc, batch, type, false, 0, 0);	
		}

		function setUniform(gl, prg, loc, type, name, val) {
			if (prg) { gl.useProgram(prg); }
			if (type === "1i") {
				gl.uniform1i(loc, val);
			} else if (type === "1f") {
				gl.uniform1f(loc, val);
			}
		}

		function render (gl, prg, buf, type, offset, count) {
			gl.bindFramebuffer(gl.FRAMEBUFFER, buf);
			gl.useProgram(prg);
			gl.drawArrays(type, offset, count);
		}

		/* these are global because I'm a laze */
		const M = 720;
		const w = 256;

		const v_quad = makeShader(gl, document.getElementById("v_quad").text, gl.VERTEX_SHADER);

		const ParticleData = function (gl) {
			this.gl = gl;

			const f_step = makeShader(gl,
			document.getElementById("f_step").text, gl.FRAGMENT_SHADER);

			this.p_step = makeProgram(gl, v_quad, f_step);
			this.p_step_prev = gl.getUniformLocation(this.p_step, "prev");
			this.p_step_time = gl.getUniformLocation(this.p_step, "time");
			this.p_step_max_age= gl.getUniformLocation(this.p_step, "max_age");
			this.p_step_octave = gl.getUniformLocation(this.p_step, "octave");
			this.p_step_x = gl.getAttribLocation(this.p_step, "x");

			const x = new Float32Array([1, 1, 1, -1, -1, 1, -1, -1]);
			this.xbuf = makeBuffer(gl, x, gl.STATIC_DRAW);


			/* data textures and framebuffers */
			let N = w*w;
			const data = new Float32Array(w*w*4);
			for (let i = 0; i < w; ++i) {
			for (let j = 0; j < w; ++j) {
				data[4*(w*i+j)  ] = 2*Math.random()-1;
				data[4*(w*i+j)+1] = 2*Math.random()-1;
				data[4*(w*i+j)+2] = Math.random();
				data[4*(w*i+j)+3] = 1;
			}}

			this.texA = makeTexture(gl, 0, gl.RGBA32F, w, w, gl.RGBA, gl.FLOAT,
			null, gl.NEAREST, gl.NEAREST, gl.REPEAT, gl.REPEAT);
			this.fbfA = makeFramebuffer(gl, this.texA, 0);

			this.texB = makeTexture(gl, 1, gl.RGBA32F, w, w, gl.RGBA, gl.FLOAT,
			data, gl.NEAREST, gl.NEAREST, gl.REPEAT, gl.REPEAT);
			this.fbfB = makeFramebuffer(gl, this.texB, 1);
			this.toA = true;

			/* carry over frames */
			this.f_fade = makeShader(gl, document.getElementById("f_fade").text, gl.FRAGMENT_SHADER);
			this.p_fade = makeProgram(gl, v_quad, this.f_fade);
			this.p_fade_x = gl.getAttribLocation(this.p_fade, "x");
			this.p_fade_prev = gl.getUniformLocation(this.p_fade, "prev");
			this.p_fade_trail= gl.getUniformLocation(this.p_fade, "trail");

			const bgtx = new Uint8Array(M*M*4);
			for (let i = 0; i < M*M; ++i) {
				bgtx[i*4+0] = 0;
				bgtx[i*4+1]	= 0;
				bgtx[i*4+2]	= 0;
				bgtx[i*4+3]	= 255;
			}

			this.texP = makeTexture(gl, 2, gl.RGBA, M, M, gl.RGBA, gl.UNSIGNED_BYTE,
			null, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT);
			this.fbfP = makeFramebuffer(gl, this.texP, 2);

			this.texQ = makeTexture(gl, 3, gl.RGBA, M, M, gl.RGBA, gl.UNSIGNED_BYTE,
			bgtx, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT);
			this.fbfQ = makeFramebuffer(gl, this.texQ, 3);


			/* render particles */
			const v_img = makeShader(gl, document.getElementById("v_img").text, gl.VERTEX_SHADER);
			const f_img = makeShader(gl, document.getElementById("f_img").text, gl.FRAGMENT_SHADER);

			this.p_img = makeProgram(gl, v_img, f_img);
			this.p_img_ij = gl.getAttribLocation(this.p_img, "ij");
			this.p_img_dat = gl.getUniformLocation(this.p_img, "dat");

			const ij = new Float32Array(N*2);
			for (let i = 0; i < w; ++i) {
			for (let j = 0; j < w; ++j) {
				ij[2*(i*w+j)  ] = i;
				ij[2*(i*w+j)+1] = j;
			}}
			this.ijbuf = makeBuffer(gl, ij, gl.STATIC_DRAW);

			this.N = w*w;
			this.trail = 0.04;
			this.clock = 0.01;
		}
		ParticleData.prototype.setParameters = function (params) {
			if (params.max_age) {
			setUniform(gl, this.p_step, this.p_step_max_age, "1f", "max_age", params.max_age);
			}

			if (params.octave) {
			setUniform(gl, this.p_step, this.p_step_octave, "1i", "octave", params.octave);
			}

			if (params.trail) {
			setUniform(gl, this.p_fade, this.p_fade_trail, "1f", "trail", params.trail);
			}

			if (params.N) {
			this.N = Math.min(params.N, w*w);
			}
			if (params.clock) {
			this.clock = params.clock;
			}
		}
		ParticleData.prototype.integrate = function (t) {
			const gl = this.gl;
			const toA = this.toA;

			setUniform(gl, this.p_step, this.p_step_prev, "1i", "prev", toA ? 1 : 0);
			setUniform(gl, this.p_step, this.p_step_time, "1f", "time", t);
			setBuffer(gl, this.p_step, this.xbuf, this.p_step_x, 2, gl.FLOAT);

			render(gl, this.p_step, toA ? this.fbfA : this.fbfB, gl.TRIANGLE_STRIP, 0, 4);
			//render(gl, this.p_step, null, gl.TRIANGLE_STRIP, 0, 4);

		}
		ParticleData.prototype.render = function () {
			const gl = this.gl;
			const toA = this.toA;

			/* render a copy of the last frame */
			setUniform(gl, this.p_fade, this.p_fade_prev, "1i", "prev", toA ? 3 : 2);
			setBuffer(gl, this.p_fade, this.xbuf, this.p_fade_x, 2, gl.FLOAT);
			render(gl, this.p_fade, toA ? this.fbfP : this.fbfQ, gl.TRIANGLE_STRIP, 0, 4);
			render(gl, this.p_fade, null, gl.TRIANGLE_STRIP, 0, 4);


			/* render updated locations */
			setUniform(gl, this.p_img, this.p_img_dat, "1i", "dat", toA ? 1 : 0);
			setBuffer(gl, this.p_img, this.ijbuf, this.p_img_ij, 2, gl.FLOAT);
			render(gl, this.p_img, toA ? this.fbfP : this.fbfQ, gl.POINTS, 0, this.N);
			render(gl, this.p_img, null, gl.POINTS, 0, this.N);
		}

		let time = Math.random()*1024-512;
		ParticleData.prototype.timestep = function () {

			time += this.clock;

			window.requestAnimationFrame(this.timestep.bind(this));
			p.integrate(time);
			p.render();

			this.toA = !this.toA;
		}

		const p = new ParticleData(gl);
		p.setParameters({
			max_age: 120,
			trail: Math.exp(-p.trail),
			octave: 31,
			N: 128*128,
			clock: p.clock
		});

		let numkeysdown = [0, 0, 0, 0, 0];
		function encode(arr) {
			let ret = 0;
			let p = 1;
			for (let i = 0; i < arr.length; ++i, p *= 2) {
				ret |= p*arr[i];
			}
			if (ret === 0) { ret = 31; }
			return ret;
		}
		function modulate(val, up, step, min, max, bottom) {
			if (up) {
				val = val*step;
				if (val < min) { val = min; }
				val = Math.min(val, max);
			} else {
				val = val/step;
				if (bottom !== undefined && val < min) { val = bottom; }
			}
			return val;
		}
		window.addEventListener('keydown', function (e) {
			if (event.repeat) { return; }
			let num = parseInt(e.key);
			if (0 < num && num < 6) {
				numkeysdown[num-1] = 1;
			}
			if (e.key === 'v') {
				p.clock = modulate(p.clock, true, 2, 0.0025, 0.08, 0.0025);
			} else if (e.key === 'c') {
				p.clock = modulate(p.clock, false, 2, 0.0025, 0.08, 0.0025);
			}
			if (e.key === 't') {
				p.trail = Math.max(p.trail/2, 0.01);
			} else if (e.key === 'r') {
				p.trail = Math.min(p.trail*2, 1.28);
			}
			
			if (e.key === 'f') {
				p.N = modulate(Math.sqrt(p.N), true, 2, 16, 256, 16);
				p.N *= p.N;
			} else if (e.key === 'd') {
				p.N = modulate(Math.sqrt(p.N), false, 2, 16, 256, 16);
				p.N *= p.N;
			}
			p.setParameters({
				octave: encode(numkeysdown),
				clock: p.clock,
				trail: Math.exp(-p.trail),
				N: p.N
			});
		});
		window.addEventListener('keyup', function (e) {
			if (event.repeat) { return; }
			let num = parseInt(e.key);
			if (0 < num && num < 6) {
				numkeysdown[num-1] = 0;
				p.setParameters({octave: encode(numkeysdown)});
			}
		});

		window.requestAnimationFrame(p.timestep.bind(p));

	</script>
	
	<div><p>
		Particles advected by a time-varying vector field. The field at each point is oriented along the contour lines of a five-octave perlin noise — the divergence of such a field vanishes. The particles are coloured by velocity.
	</p>
	<ul>
	<li>1-5: display individual octaves.</li>
	<li>R/T: adjust particle trails.</li>
	<li>D/F: adjust particle feed rate.</li>
	<li>C/V: adjust time variance.</li>
	</ul></div>

	<div id = "credits">
	J. Lo, June 2018.
	</div>

</div>

</body>
</html>
