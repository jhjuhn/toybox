<!DOCTYPE HTML>
<html>
<head>
<link href = 'https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel = 'stylesheet' type = 'text/css'>
<style>
body {
	margin: 0; padding: 0;
	background-color: #0a0030;
	color: #637;

	font-family: 'open sans', sans-serif;
	font-size: 14px;
}
h2 { font-size: 18px; }

/*UI*/

#container {
	width: 720px;
	margin: 4px auto;
}
#credits{
	margin-top: 16px;
	font-size: 12px;
}

.shifted {
	background-color: #180038;
	color: #758;
}

/* WORLD*/

#world {
	border: 1px #ccc none;/*dashed;*/

	margin: 4px auto;

	position: relative;

	width: 720px;
	height: 720px;

	/*overflow: hidden;*/
}

</style>

<script id = "vsh" type = "text/GLSL">
precision mediump float;

attribute vec2 x;

varying vec2 tex_x;

void main ()
{
	tex_x = x;
	gl_Position = vec4(x, 0., 1.);
}
</script>
<script id = "fsh-M" type = "text/GLSL">
precision mediump float;

varying vec2 tex_x;

const vec2 offset = vec2(0.7, 0);

vec2 mul (vec2 z1, vec2 z2)
{
	return vec2(
		z1.x*z2.x-z1.y*z2.y,
		z1.x*z2.y+z2.x*z1.y);
}

vec2 f (vec2 z, vec2 c)
{
	return mul(z, z)+c;
}

const float scale = 2.;

/* colour from parameter in [0, 1] */
const vec4 col_A = vec4(0.2, 0.0, 0.3, 1.0); // purple
const vec4 col_B = vec4(1.0, 0.3, 0.2, 1.0); // orange
vec4 palette(float h)
{
	float w = h/100.;
	float q = min(1., h/10.);
	return vec4(-.05, w, w, 1.) +
	(cos(q)*col_A + sin(q)*col_B)*0.8;
}

void main ()
{
	vec2 c = tex_x*scale-offset;
	vec2 z = vec2(0., 0.);

	vec4 frag_color;

	const int max_iter = 512;
	int iter = max_iter;

	float cutoff = 5.;

	for (int i = 0; i < 100; ++i) {
		z = mul(z, z) + c;

		if (length(z) > cutoff) {
			iter = i;
			break;
		}
	}

	gl_FragColor = palette(float(iter));
}
</script>

<script id = "fsh-J" type = "text/GLSL">
#define M_PI = 3.1415926536
precision mediump float;

varying vec2 tex_x;
uniform vec2 c;

vec2 mul (vec2 z1, vec2 z2)
{
	return vec2(
		z1.x*z2.x-z1.y*z2.y,
		z1.x*z2.y+z2.x*z1.y);
}

const float scale = 2.;

/* colour from parameter in [0, 1] */
const vec4 col_A = vec4(0.2, 0.0, 0.3, 1.0); // purple
const vec4 col_B = vec4(1.0, 0.3, 0.2, 1.0); // orange
vec4 palette(float h)
{
	float w = h/100.;
	float q = min(1., h/10.);
	return vec4(-.05, w, w, 1.) +
	(cos(q)*col_A + sin(q)*col_B)*0.8;
}

void main ()
{
	vec2 z = tex_x*scale;

	vec4 frag_color;

	const int max_iter = 512;
	int iter = max_iter;

	float cutoff = 5.;

	for (int i = 0; i < max_iter; ++i) {

		z = mul(z, z) + c;

		if (length(z) > cutoff) {
			iter = i;
			break;
		}
	}

	float h = float(iter);
	gl_FragColor = palette(h);
}
</script>
</head>
<body>

<div id = "container">
	<h2>JULIA SETS</h2>

	<canvas id = "world" width = "720" height = "720"></canvas>
	<script>

		function makeShader (gl, type, src)
		{
			const sh = gl.createShader(type);
			gl.shaderSource(sh, src);
			gl.compileShader(sh);
			if (gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
				return sh;
			}

			console.log(gl.getShaderInfoLog(sh));
			gl.deleteShader(sh);
		}

		function makeProgram (gl, vsh, fsh)
		{
			const prg = gl.createProgram();
			gl.attachShader(prg, vsh);
			gl.attachShader(prg, fsh);
			gl.linkProgram(prg);
			if (gl.getProgramParameter(prg, gl.LINK_STATUS)) {
				return prg;
			}

			console.log(gl.getProgramInfoLog(prg));
			gl.deleteProgram(prg)
		}

		function init ()
		{
			const canvas = document.getElementById("world");
			const gl = canvas.getContext("webgl");

			const vsh = makeShader(
				gl,	gl.VERTEX_SHADER,
				document.getElementById("vsh").text);

			const fshJ = makeShader(
				gl, gl.FRAGMENT_SHADER,
				document.getElementById("fsh-J").text);

			const fshM = makeShader(
				gl, gl.FRAGMENT_SHADER,
				document.getElementById("fsh-M").text);
		
			const prgJ = makeProgram(gl, vsh, fshJ);
			const prgM = makeProgram(gl, vsh, fshM);

			const x_data = new Float32Array([
				 1,  1,
				 1, -1,
				-1,  1,
				-1, -1]);

			const x_buf = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, x_buf);
			gl.bufferData(gl.ARRAY_BUFFER, x_data, gl.STATIC_DRAW);

			/* for Julia */
			gl.useProgram(prgJ);
			const x_locJ = gl.getAttribLocation(prgJ, "x");
			gl.enableVertexAttribArray(x_locJ);
			gl.vertexAttribPointer(x_locJ, 2, gl.FLOAT, false, 0, 0);

			const c_locJ = gl.getUniformLocation(prgJ, "c");
			gl.uniform2f(c_locJ, -0.21, -0.66);
			//gl.uniform2f(c_locJ, -0.214, -0.67);

			/* for Mandelbrot */
			gl.useProgram(prgM);
			const x_locM = gl.getAttribLocation(prgM, "x");
			gl.enableVertexAttribArray(x_locM);
			gl.vertexAttribPointer(x_locM, 2, gl.FLOAT, false, 0, 0);

			gl.useProgram(prgJ);

			return {
				gl: gl,
				prg: {
					J: prgJ,
					M: prgM
				},
				a_loc: {
					J: { x: x_locJ },
					M: { x: x_locM }
				},
				u_loc: {
					J: { c: c_locJ },
					M: {},
				},
				buf: {
					x: x_buf
				},
			};

		}

		function render (state)
		{
			state.gl.drawArrays(state.gl.TRIANGLE_STRIP, 0, 4);
		}

		let active = 1;
		const state = init();
		render(state);

		/* parameters for Julia renderer */
		let cx = 0; let cy = 0;
		let offsetx = 0.8; let offsety = 0;
		const scale = 2.0;


		const deactivate = function () {
			active = 0;
			state.gl.useProgram(state.prg.M);
			render(state);


			/* change style, last minute hacky thing */
			document.body.className = "shifted";

			console.log(cx + ' + ' + cy + 'i');
		}

		const activate = function () {
			active = 1;
			state.gl.useProgram(state.prg.J);
			render(state);

			document.body.className = "";
		}

		const canv = document.getElementById('world');
		window.addEventListener('mouseup', activate);
		window.addEventListener('mousedown', deactivate);

		window.addEventListener('mousemove', function (e) {
			if (!active) { return; }

			const rect = canv.getBoundingClientRect();
			const x = e.clientX - rect.left;
			const y = e.clientY - rect.top;

			cx = 2*x/canv.width-1;
			cx = cx*scale-offsetx;

			cy = -2*y/canv.width+1;
			cy = cy*scale-offsety;

			state.gl.useProgram(state.prg.J);
			state.gl.uniform2f(state.u_loc.J.c, cx, cy);
			render(state);
		});

	</script>
	
	<div><p>Rendering of Julia sets of the family of complex quadratic polynomials <i>f<sub>c</sub>(z) = z<sup>2</sup> + c</i>, coloured by rate of convergence. The parameter <i>c</i> is computed from the location of the cursor in the window; click or hold to show the the Mandelbrot set rendered on the corresponding complex plane.</p></div>

	<div id = "credits">
	J. Lok, April 2018.
	</div>

</div>


</body>

</html>
