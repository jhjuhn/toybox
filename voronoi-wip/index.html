<!DOCTYPE HTML>
<html>
<head>
<link href = 'https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel = 'stylesheet' type = 'text/css'>
<style>
html, body {
	margin: 0; padding: 0;
	background-color: #111;
	color: #999;

	font-family: 'open sans', sans-serif;
	font-size: 14px;
}
h2 { font-size: 18px; }

/*UI*/

#container {
	width: 720px;
	margin: 4px auto;
}
#credits{
	margin-top: 16px;
	font-size: 12px;
}

/* WORLD*/

#world {
	border: 1px #ccc none;/*dashed;*/

	margin: 4px auto;

	position: relative;

	width: 720px;
	height: 720px;

	/*overflow: hidden;*/
}

</style>

<script id = "v_quad" type = "text/glsl">#version 300 es
in vec2 x; void main () { gl_Position = vec4(x, 0., 1.); }
</script>

<script id = "v_seed" type = "text/glsl">#version 300 es
uniform sampler2D site;
in float i;
out float j;
void main ()
{
	gl_Position = vec4(texelFetch(site, ivec2(i, 0), 0).xy*2.-1., 0., 1.);
	j = i;
	gl_PointSize = 4.0;
}
</script>

<script id = "f_seed" type = "text/glsl">#version 300 es
precision mediump float;

in float j;
uniform sampler2D site;

out vec4 frag_colour;

void main ()
{
	vec2 xy = texelFetch(site, ivec2(j, 0), 0).xy;
	frag_colour = vec4(xy, j+1., 1.);
}
</script>

<script id = "f_step" type = "text/glsl">#version 300 es
precision mediump float;

uniform sampler2D prev;
uniform float stepsize;

out vec4 frag_colour;

const vec4 bg = vec4(0., 0., 0., 1.);
const vec2[8] dx = vec2[8](
	vec2( 1., 0.), vec2( 1., 1.), vec2( 0., 1.), vec2(-1., 1.),
	vec2(-1., 0.), vec2(-1.,-1.), vec2( 0.,-1.), vec2( 1.,-1.)
);

vec4 compare (vec2 xy, float len, vec4 col, vec2 offset) {
	vec4 st = texture(prev, xy + offset);
	return mix(col, st, float(
	(col == bg) || ((st != bg) && (distance(st.xy, xy) < len))));
}

void main ()
{
	vec2 xy = gl_FragCoord.xy / 720.;
	float l = stepsize/720.;
	float len;
	frag_colour = texture(prev, xy);
	for (int i = 0; i < 8; ++i) {
		frag_colour = compare(
			xy, distance(xy, frag_colour.xy),
			frag_colour, l*dx[i]);
	}
}
</script>

<script id = "f_1", type = "text/glsl">#version 300 es
#define rho 0.001
precision mediump float;

uniform sampler2D src;

out vec4 frag_colour;

void main () {
	int Y = int(gl_FragCoord.y);
	int s = int(gl_FragCoord.x);

	frag_colour = vec4(0., 0., 0., 1.);
	float y = gl_FragCoord.y/720.;
	for (int i = 0; i < 720; ++i) {
		frag_colour += mix(
			vec4(0., 0., 0., 0.),
			vec4(vec2(float(i)/720., y)*rho, rho, 0.),
			float(int(texelFetch(src, ivec2(i, Y), 0).z-1.) == s));
	}

}
</script>
<script id = "f_2", type = "text/glsl">#version 300 es
precision mediump float;

uniform sampler2D src;
uniform int n;
uniform vec2 cursor;

out vec4 frag_colour;

void main () {
	ivec2 uv = ivec2(gl_FragCoord.xy);

	int i = uv.x;

	frag_colour = vec4(0., 0., 0., 1.);
	for (int j = 0; j < 720; ++j) {
		frag_colour += texelFetch(src, ivec2(i, j), 0);
	}
	vec2 Wx = frag_colour.xy;
	float W = frag_colour.z;

	if (i == n) {
		frag_colour = vec4(cursor, 0., 1.);
	} else {
		frag_colour = vec4(Wx/W+4e-4, 0., 1.);
	}
}
</script>
</head>
<body>

<div id = "container">
	<h2>TITLE</h2>

	<canvas id = "world" width = "720" height = "720"></canvas>
	<script src="../shared/gl2.js"></script>	
	<script>
		const canv = document.getElementById("world");
		const gl = canv.getContext("webgl2");
		if (!gl) { throw "error: webgl2 not supported."; }
		gl.clearColor(0, 0, 0, 1);

		const ext = gl.getExtension("EXT_color_buffer_float");
		if (!ext) {	throw "error: rendering to float texture not supported."; }

		/* shared quad shader & buffer data */
		const v_quad = makeShader(gl, document.getElementById("v_quad").text, gl.VERTEX_SHADER);

		const x = new Float32Array([ 1, 1, 1, -1, -1, 1, -1, -1]);
		const b_x = makeBuffer(gl, x, gl.STATIC_DRAW);

		const W = 720;
		const N = 360;
		let n = 360;

		const Voronoi = function (gl) {
			this.gl = gl;
			
			this.f_step = makeShader(gl,
			document.getElementById("f_step").text, gl.FRAGMENT_SHADER);

			this.v_seed = makeShader(gl,
			document.getElementById("v_seed").text, gl.VERTEX_SHADER);
			this.f_seed = makeShader(gl,
			document.getElementById("f_seed").text, gl.FRAGMENT_SHADER);

			this.p_step = makeProgram(gl, v_quad, this.f_step);
			this.p_step_x = gl.getAttribLocation(this.p_step, "x");
			this.p_step_prev = gl.getUniformLocation(this.p_step, "prev");
			this.p_step_stepsize = gl.getUniformLocation(this.p_step, "stepsize");

			this.p_seed = makeProgram(gl, this.v_seed, this.f_seed);
			this.p_seed_i = gl.getAttribLocation(this.p_seed, "i");
			this.p_seed_site = gl.getUniformLocation(this.p_seed, "site");

			const index = new Float32Array(N);
			for (let i = 0; i < N; ++i) {
				index[i] = i;
			}
			this.i_buf = makeBuffer(gl, index, gl.STATIC_DRAW);

			const site = new Float32Array(N*4);
			for (let i = 0; i < N; ++i) {
				site[4*i+0] = Math.random();
				site[4*i+1] = Math.random();
				site[4*i+2] = 0;
				site[4*i+3] = 0;
			}
			this.texS = makeTexture(gl, 0, gl.RGBA32F, N, 1, gl.RGBA, gl.FLOAT,
			site, gl.NEAREST, gl.NEAREST, gl.REPEAT, gl.REPEAT);
			this.fbfS = makeFramebuffer(gl, this.texS, 0);

			/* framebuffers for ping-pong-ing */
			this.texA = makeTexture(gl, 1, gl.RGBA32F, W, W, gl.RGBA, gl.FLOAT,
			null, gl.NEAREST, gl.NEAREST, gl.REPEAT, gl.REPEAT);
			this.fbfA = makeFramebuffer(gl, this.texA, 1);

			this.texB = makeTexture(gl, 2, gl.RGBA32F, W, W, gl.RGBA, gl.FLOAT,
			null, gl.NEAREST, gl.NEAREST, gl.REPEAT, gl.REPEAT);
			this.fbfB = makeFramebuffer(gl, this.texB, 2);

			this.toA = true;
		}
		Voronoi.prototype.seed = function () {
			const gl = this.gl;

			setBuffer(gl, this.p_seed, this.p_seed_i, this.i_buf, 1, gl.FLOAT);
			setUniform(gl, this.p_seed, this.p_seed_site, "1i", 0);

			render(gl, this.p_seed, this.fbfB, gl.POINTS, 0, n, true);
			render(gl, this.p_seed, null, gl.POINTS, 0, n, true);
		}
		Voronoi.prototype.pingpong = function () {
			const gl = this.gl;
			setBuffer(gl, this.p_step, this.p_step_x, b_x, 2, gl.FLOAT);

			let stepsize = 720;
			const iter = Math.log2(stepsize)+2;
			gl.useProgram(this.p_step);

			for (let i = 0; i < iter; ++i) {
				setUniform(gl, null, this.p_step_prev, "1i", this.toA ? 2 : 1);
				setUniform(gl, null, this.p_step_stepsize, "1f", stepsize);
				render(gl, null, this.toA ? this.fbfA : this.fbfB, gl.TRIANGLE_STRIP, 0, 4);

				this.toA = ! this.toA;
				stepsize /= 2;
			}
			render(gl, this.p_step, null, gl.TRIANGLE_STRIP, 0, 4);

		}

		const Lloyd = function (gl, vor) {
			this.gl = gl;

			this.f_1= makeShader(gl,
			document.getElementById("f_1").text, gl.FRAGMENT_SHADER);

			this.f_2= makeShader(gl,
			document.getElementById("f_2").text, gl.FRAGMENT_SHADER);

			this.p_1 = makeProgram(gl, v_quad, this.f_1);
			this.p_1_x = gl.getAttribLocation(this.p_1, "x");
			this.p_1_src = gl.getUniformLocation(this.p_1, "src");
			setUniform(gl, this.p_1, this.p_1_src, "1i", vor);

			this.p_2 = makeProgram(gl, v_quad, this.f_2);
			this.p_2_x = gl.getAttribLocation(this.p_2, "x");
			this.p_2_src = gl.getUniformLocation(this.p_2, "src");
			setUniform(gl, this.p_2, this.p_2_src, "1i", 3);

			this.p_2_n = gl.getUniformLocation(this.p_2, "n");
			this.p_2_cursor = gl.getUniformLocation(this.p_2, "cursor");

			this.texC = makeTexture(gl, 3, gl.RGBA32F, N, W, gl.RGBA, gl.FLOAT,
			null, gl.NEAREST, gl.NEAREST, gl.REPEAT, gl.REPEAT);
			this.fbfC = makeFramebuffer(gl, this.texC, 3);
		}
		Lloyd.prototype.calculate = function (targ, ni, cur) {
			const gl = this.gl;

			setBuffer(gl, this.p_1, this.p_1_x, b_x, 2, gl.FLOAT);
			render(gl, null, this.fbfC, gl.TRIANGLE_STRIP, 0, 4);

			setBuffer(gl, this.p_2, this.p_2_x, b_x, 2, gl.FLOAT);
			setUniform(gl, this.p_2, this.p_2_n, "1i", ni); 
			setUniform(gl, this.p_2, this.p_2_cursor, "2f", cur);
			render(gl, null, targ, gl.TRIANGLE_STRIP, 0, 4);

			if (generate) { ++n; }
		}

		const v = new Voronoi(gl);
		const l = new Lloyd(gl, 2);

		let generate = false;
		let cursor = [0, 0];
		function updateCursorLocation (e) {
			const rect = e.target.getBoundingClientRect();
			console.log(rect);
			cursor[0] = (e.clientX - rect.left)/rect.width;
			cursor[1] = 1-(e.clientY - rect.top)/rect.height;
		}
		canv.addEventListener('mousedown', function (e) {
			generate = true;
			updateCursorLocation(e);
		});
		canv.addEventListener('mousemove', function (e) {
			updateCursorLocation(e);
		});
		canv.addEventListener('mouseup', function (e) {
			generate = false;
		});
		canv.addEventListener('mouseleave', function (e) {
			generate = false;
		});
		

		function timestep () {
			window.setTimeout(function () {
				window.requestAnimationFrame(timestep);
			}, 80);

			v.seed();
			v.pingpong();
			l.calculate(v.fbfS, generate ? n : N, cursor);
			if (generate) { n = Math.min(n, N); }
		}
		timestep();
	</script>
	<div><p>description.</p></div>

	<div id = "credits">
	J. Lo, [M] [yyyy].
	</div>

</div>

</body>
</html>
